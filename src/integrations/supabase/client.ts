// This file is automatically generated. Do not edit it directly.
import { createClient } from '@supabase/supabase-js';
import { toast } from 'sonner';
import type { Database } from './types';

// Use environment variables from .env
const SUPABASE_URL = import.meta.env.VITE_SUPABASE_URL || "https://vqdlsidkucrownbfuouq.supabase.co";
const SUPABASE_PUBLISHABLE_KEY = import.meta.env.VITE_SUPABASE_ANON_KEY || "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InZxZGxzaWRrdWNyb3duYmZ1b3VxIiwicm9sZSI6ImFub24iLCJpYXQiOjE3MzQzMDc4NDgsImV4cCI6MjA0OTg4Mzg0OH0.ARDnjN_J_bz74zQfV7IRDrq6ZL5-xs9L21zI3eG6O5Y";

// Create client with improved retry configuration and connection recovery mechanisms
export const supabase = createClient<Database>(
  SUPABASE_URL, 
  SUPABASE_PUBLISHABLE_KEY,
  {
    auth: {
      persistSession: true,
      autoRefreshToken: true,
    },
    global: {
      fetch: (...args) => {
        // Enhanced fetch with automatic retry logic for network issues
        const fetchWithRetry = async (retries = 5, backoffDelay = 300) => {
          try {
            // Implement timeout to prevent hanging requests
            const controller = new AbortController();
            const timeoutId = setTimeout(() => controller.abort(), 10000); // 10 second timeout
            
            const fetchArgs: any = [...args];
            // Add the signal to the fetch options
            if (fetchArgs[1]) {
              fetchArgs[1].signal = controller.signal;
            } else {
              fetchArgs[1] = { signal: controller.signal };
            }
            
            const response = await fetch(...fetchArgs);
            clearTimeout(timeoutId);
            return response;
          } catch (err) {
            console.warn(`Fetch attempt failed, retries left: ${retries}`, err);
            if (retries <= 0) {
              throw err;
            }
            
            // Check for network connectivity before retrying
            if (!navigator.onLine) {
              console.log("Browser reports offline status. Waiting for connection...");
              await new Promise(resolve => {
                const onlineHandler = () => {
                  window.removeEventListener('online', onlineHandler);
                  resolve(true);
                };
                window.addEventListener('online', onlineHandler);
              });
            }
            
            // Exponential backoff with jitter
            const jitter = Math.random() * 0.3 + 0.85; // 0.85-1.15 random factor
            await new Promise(resolve => setTimeout(resolve, backoffDelay * jitter));
            return fetchWithRetry(retries - 1, Math.min(backoffDelay * 2, 10000));
          }
        };
        
        return fetchWithRetry();
      },
      headers: {
        'x-application-name': 'fleet-management-system',
        'x-client-info': 'supabase-js/2.38.4',
      },
    },
    // Improve retry configuration for better resilience
    retryAttempts: 5,
    retryInterval: attempt => Math.min(1000 * Math.pow(2, attempt), 15000), // Exponential backoff with max 15s
  }
);

// Connection status cache to avoid repeated health checks
let lastHealthCheck = {
  timestamp: 0,
  isHealthy: true,
  error: null as string | null
};
const HEALTH_CACHE_TTL = 5000; // Reduced to 5 seconds from 10 seconds

// Add a function to test connection with better caching and reliability
export const testConnection = async (): Promise<boolean> => {
  try {
    // Use cached result if recent
    const now = Date.now();
    if (now - lastHealthCheck.timestamp < HEALTH_CACHE_TTL) {
      return lastHealthCheck.isHealthy;
    }
    
    // Perform lightweight health check
    const { error } = await supabase.from('vehicles').select('count', { count: 'exact', head: true });
    
    const isHealthy = !error;
    
    // Update cache
    lastHealthCheck = {
      timestamp: now,
      isHealthy,
      error: error ? error.message : null
    };
    
    return isHealthy;
  } catch (err) {
    console.error('Supabase connection test failed:', err);
    
    // Update cache with error state
    lastHealthCheck = {
      timestamp: Date.now(),
      isHealthy: false,
      error: err instanceof Error ? err.message : 'Unknown connection error'
    };
    
    return false;
  }
};

// Export an enhanced health check function with detailed diagnostics
export const checkSupabaseHealth = async (): Promise<{ 
  isHealthy: boolean; 
  error?: string; 
  latency?: number;
  timestamp: number;
  connectionCount?: number;
}> => {
  const MAX_RETRIES = 3;
  let retryCount = 0;
  try {
    // Use cached result if recent
    const now = Date.now();
    if (now - lastHealthCheck.timestamp < HEALTH_CACHE_TTL) {
      return { 
        isHealthy: lastHealthCheck.isHealthy,
        error: lastHealthCheck.error || undefined,
        timestamp: lastHealthCheck.timestamp
      };
    }
    
    // Gradually more thorough checks based on retry count
    let error = null;
    let isHealthy = false;
    let startTime = performance.now();
    
    while (retryCount < MAX_RETRIES && !isHealthy) {
      try {
        // Try a different lightweight query each retry
        if (retryCount === 0) {
          const response = await supabase.from('vehicles').select('count', { count: 'exact', head: true });
          error = response.error;
        } else if (retryCount === 1) {
          const response = await supabase.from('vehicle_types').select('count', { count: 'exact', head: true });
          error = response.error;
        } else {
          const response = await supabase.rpc('get_server_time');
          error = response.error;
        }
        
        isHealthy = !error;
        if (isHealthy) break;
        
        console.log(`Health check attempt ${retryCount + 1} failed: ${error?.message}`);
        retryCount++;
        await new Promise(r => setTimeout(r, 500 * retryCount)); // Exponential backoff
      } catch (err) {
        error = err;
        retryCount++;
        if (retryCount < MAX_RETRIES) {
          await new Promise(r => setTimeout(r, 500 * retryCount));
        }
      }
    }
    
    const endTime = performance.now();
    const latency = Math.round(endTime - startTime);
    
    if (!isHealthy) {
      console.error('All Supabase health check attempts failed:', error);
      
      // Update cache
      lastHealthCheck = {
        timestamp: now,
        isHealthy: false,
        error: error ? (error instanceof Error ? error.message : String(error)) : 'Unknown database error'
      };
      
      return { 
        isHealthy: false, 
        error: error ? (error instanceof Error ? error.message : String(error)) : 'Unknown database error',
        latency,
        timestamp: now
      };
    }
    
    // Update cache with healthy state
    lastHealthCheck = {
      timestamp: now,
      isHealthy: true,
      error: null
    };
    
    return { 
      isHealthy: true,
      latency,
      timestamp: now
    };
  } catch (err) {
    const errorMessage = err instanceof Error ? err.message : 'Unknown error checking Supabase connection';
    console.error('Supabase connection error:', errorMessage);
    
    // Update cache with error state
    lastHealthCheck = {
      timestamp: Date.now(),
      isHealthy: false,
      error: errorMessage
    };
    
    return { 
      isHealthy: false, 
      error: errorMessage,
      timestamp: Date.now()
    };
  }
};

// Check connection with multiple retries and exponential backoff
export const checkConnectionWithRetry = async (
  retries = 3, 
  initialDelay = 1000
): Promise<boolean> => {
  let attempts = 0;
  let delay = initialDelay;
  
  while (attempts < retries) {
    const { isHealthy } = await checkSupabaseHealth();
    if (isHealthy) return true;
    
    attempts++;
    if (attempts < retries) {
      console.log(`Connection attempt ${attempts} failed, retrying in ${delay}ms...`);
      await new Promise(resolve => setTimeout(resolve, delay));
      delay = Math.min(delay * 2, 10000); // Exponential backoff with max 10s
    }
  }
  
  console.error(`Failed to connect to database after ${retries} attempts`);
  return false;
};

// A unified function to monitor database connectivity with UI feedback
export const monitorDatabaseConnection = (
  onConnectionChange?: (status: { isConnected: boolean, error?: string }) => void,
  pollingIntervalMs = 30000
): () => void => {
  let previousStatus = true;
  
  const checkConnection = async () => {
    const { isHealthy, error, latency } = await checkSupabaseHealth();
    
    // Only notify if the status has changed
    if (isHealthy !== previousStatus) {
      previousStatus = isHealthy;
      
      if (!isHealthy) {
        console.error(`Database connection lost: ${error}`);
        toast.error('Database connection lost', {
          description: `Cannot connect to database: ${error || 'Check your internet connection'}`,
          duration: 0, // Keep until dismissed or reconnected
          id: 'db-connection-error'
        });
      } else {
        console.log(`Database connection restored (latency: ${latency}ms)`);
        toast.success('Database connection restored', {
          description: 'Your connection to the database has been re-established',
          id: 'db-connection-error'
        });
      }
      
      if (onConnectionChange) {
        onConnectionChange({ isConnected: isHealthy, error });
      }
    }
  };
  
  // Do an initial check
  checkConnection();
  
  // Set up regular polling
  const interval = setInterval(checkConnection, pollingIntervalMs);
  
  // Return function to clear the interval
  return () => clearInterval(interval);
};

// Connection monitoring with event listeners for online/offline status
let offlineToastId: string | number | null = null;

// Add network status event listeners
export const setupNetworkMonitoring = () => {
  window.addEventListener('offline', () => {
    console.warn('Browser went offline');
    offlineToastId = toast.error('Connection lost', {
      description: 'Your device appears to be offline. Some features may be unavailable.',
      duration: Infinity,
      id: 'connection-offline'
    });
  });

  window.addEventListener('online', () => {
    console.log('Browser came back online');
    if (offlineToastId) {
      toast.dismiss(offlineToastId);
      toast.success('Connection restored', {
        description: 'Your device is back online. All features should work properly now.',
        duration: 3000,
      });
      
      // Force reset the connection status
      lastHealthCheck = {
        timestamp: 0,
        isHealthy: true,
        error: null
      };
      
      // Test the connection after coming back online
      testConnection().then(isHealthy => {
        if (!isHealthy) {
          toast.error('Database connection issue', {
            description: 'There might still be connectivity issues with the database. Please try again later.',
            duration: 5000,
          });
        }
      });
    }
    offlineToastId = null;
  });
  
  // Initial connection check
  if (!navigator.onLine) {
    offlineToastId = toast.error('Connection unavailable', {
      description: 'Your device appears to be offline. Some features may be unavailable.',
      duration: Infinity,
      id: 'connection-offline'
    });
  }
};

// Initialize network monitoring
if (typeof window !== 'undefined') {
  setupNetworkMonitoring();
}
