
// This file is automatically generated. Do not edit it directly.
import { createClient } from '@supabase/supabase-js';
import { toast } from 'sonner';
import type { Database } from './types';
import { logOperation } from '@/utils/monitoring-utils';

// Use environment variables from .env
const SUPABASE_URL = import.meta.env.VITE_SUPABASE_URL || "https://vqdlsidkucrownbfuouq.supabase.co";
const SUPABASE_PUBLISHABLE_KEY = import.meta.env.VITE_SUPABASE_ANON_KEY || "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InZxZGxzaWRrdWNyb3duYmZ1b3VxIiwicm9sZSI6ImFub24iLCJpYXQiOjE3MzQzMDc4NDgsImV4cCI6MjA0OTg4Mzg0OH0.ARDnjN_J_bz74zQfV7IRDrq6ZL5-xs9L21zI3eG6O5Y";

// Create client with improved retry configuration and connection recovery mechanisms
export const supabase = createClient<Database>(
  SUPABASE_URL, 
  SUPABASE_PUBLISHABLE_KEY,
  {
    auth: {
      persistSession: true,
      autoRefreshToken: true,
    },
    global: {
      fetch: (...args) => {
        // Enhanced fetch with automatic retry logic for network issues
        const fetchWithRetry = async (retries = 3, backoffDelay = 300) => {
          try {
            return await fetch(...args);
          } catch (err) {
            if (retries <= 0) {
              throw err;
            }
            // Exponential backoff
            await new Promise(resolve => setTimeout(resolve, backoffDelay));
            return fetchWithRetry(retries - 1, backoffDelay * 2);
          }
        };
        return fetchWithRetry();
      },
      headers: {
        'x-application-name': 'fleet-management-system',
        'x-client-info': 'supabase-js/2.38.4',
      },
    },
    // Improve retry configuration for better resilience
    retryAttempts: 5,
    retryInterval: attempt => Math.min(1000 * Math.pow(2, attempt), 10000), // Exponential backoff with max 10s
  }
);

// Connection status cache to avoid repeated health checks
let lastHealthCheck = {
  timestamp: 0,
  isHealthy: true,
  error: null as string | null
};
const HEALTH_CACHE_TTL = 5000; // Reduced to 5 seconds from 10 seconds

// Add a function to test connection with better caching and reliability
export const testConnection = async (): Promise<boolean> => {
  try {
    // Use cached result if recent
    const now = Date.now();
    if (now - lastHealthCheck.timestamp < HEALTH_CACHE_TTL) {
      return lastHealthCheck.isHealthy;
    }
    
    // Perform lightweight health check
    const { error } = await supabase.from('vehicles').select('count', { count: 'exact', head: true });
    
    const isHealthy = !error;
    
    // Update cache
    lastHealthCheck = {
      timestamp: now,
      isHealthy,
      error: error ? error.message : null
    };
    
    return isHealthy;
  } catch (err) {
    logOperation('supabase.testConnection', 'error', 
      { error: err instanceof Error ? err.message : String(err) }, 'Supabase connection test failed');
    
    // Update cache with error state
    lastHealthCheck = {
      timestamp: Date.now(),
      isHealthy: false,
      error: err instanceof Error ? err.message : 'Unknown connection error'
    };
    
    return false;
  }
};

// Export an enhanced health check function with detailed diagnostics
export const checkSupabaseHealth = async (): Promise<{ 
  isHealthy: boolean; 
  error?: string; 
  latency?: number;
  timestamp: number;
  connectionCount?: number;
}> => {
  const MAX_RETRIES = 3;
  let retryCount = 0;
  try {
    // Use cached result if recent
    const now = Date.now();
    if (now - lastHealthCheck.timestamp < HEALTH_CACHE_TTL) {
      return { 
        isHealthy: lastHealthCheck.isHealthy,
        error: lastHealthCheck.error || undefined,
        timestamp: lastHealthCheck.timestamp
      };
    }
    
    // Gradually more thorough checks based on retry count
    let error = null;
    let isHealthy = false;
    let startTime = performance.now();
    
    while (retryCount < MAX_RETRIES && !isHealthy) {
      try {
        // Try a different lightweight query each retry
        if (retryCount === 0) {
          const response = await supabase.from('vehicles').select('count', { count: 'exact', head: true });
          error = response.error;
        } else if (retryCount === 1) {
          const response = await supabase.from('vehicle_types').select('count', { count: 'exact', head: true });
          error = response.error;
        } else {
          const response = await supabase.rpc('get_server_time');
          error = response.error;
        }
        
        isHealthy = !error;
        if (isHealthy) break;
        
        logOperation('supabase.checkSupabaseHealth', 'warning', 
          { attempt: retryCount + 1, error: error?.message }, `Health check attempt failed`);
        retryCount++;
        await new Promise(r => setTimeout(r, 500 * retryCount)); // Exponential backoff
      } catch (err) {
        error = err;
        retryCount++;
        if (retryCount < MAX_RETRIES) {
          await new Promise(r => setTimeout(r, 500 * retryCount));
        }
      }
    }
    
    const endTime = performance.now();
    const latency = Math.round(endTime - startTime);
    
    if (!isHealthy) {
      logOperation('supabase.checkSupabaseHealth', 'error', 
        { error: error instanceof Error ? error.message : String(error) }, 'All Supabase health check attempts failed');
      
      // Update cache
      lastHealthCheck = {
        timestamp: now,
        isHealthy: false,
        error: error ? (error instanceof Error ? error.message : String(error)) : 'Unknown database error'
      };
      
      return { 
        isHealthy: false, 
        error: error ? (error instanceof Error ? error.message : String(error)) : 'Unknown database error',
        latency,
        timestamp: now
      };
    }
    
    // Update cache with healthy state
    lastHealthCheck = {
      timestamp: now,
      isHealthy: true,
      error: null
    };
    
    return { 
      isHealthy: true,
      latency,
      timestamp: now
    };
  } catch (err) {
    const errorMessage = err instanceof Error ? err.message : 'Unknown error checking Supabase connection';
    logOperation('supabase.checkSupabaseHealth', 'error', 
      { error: errorMessage }, 'Supabase connection error');
    
    // Update cache with error state
    lastHealthCheck = {
      timestamp: Date.now(),
      isHealthy: false,
      error: errorMessage
    };
    
    return { 
      isHealthy: false, 
      error: errorMessage,
      timestamp: Date.now()
    };
  }
};

// Check connection with multiple retries and exponential backoff
export const checkConnectionWithRetry = async (
  retries = 3, 
  initialDelay = 1000
): Promise<boolean> => {
  let attempts = 0;
  let delay = initialDelay;
  
  while (attempts < retries) {
    const { isHealthy } = await checkSupabaseHealth();
    if (isHealthy) return true;
    
    attempts++;
    if (attempts < retries) {
      logOperation('supabase.checkConnectionWithRetry', 'warning', 
        { attempt: attempts, delay }, `Connection attempt failed, retrying`);
      await new Promise(resolve => setTimeout(resolve, delay));
      delay = Math.min(delay * 2, 10000); // Exponential backoff with max 10s
    }
  }
  
  logOperation('supabase.checkConnectionWithRetry', 'error', 
    { retries }, `Failed to connect to database after ${retries} attempts`);
  return false;
};

// A unified function to monitor database connectivity with UI feedback
export const monitorDatabaseConnection = (
  onConnectionChange?: (status: { isConnected: boolean, error?: string }) => void,
  pollingIntervalMs = 30000
): () => void => {
  let previousStatus = true;
  
  const checkConnection = async () => {
    const { isHealthy, error, latency } = await checkSupabaseHealth();
    
    // Only notify if the status has changed
    if (isHealthy !== previousStatus) {
      previousStatus = isHealthy;
      
      if (!isHealthy) {
        logOperation('supabase.monitorDatabaseConnection', 'error', 
          { error }, 'Database connection lost');
        toast.error('Database connection lost', {
          description: `Cannot connect to database: ${error || 'Check your internet connection'}`,
          duration: 0, // Keep until dismissed or reconnected
          id: 'db-connection-error'
        });
      } else {
        logOperation('supabase.monitorDatabaseConnection', 'success', 
          { latency }, 'Database connection restored');
        toast.success('Database connection restored', {
          description: 'Your connection to the database has been re-established',
          id: 'db-connection-error'
        });
      }
      
      if (onConnectionChange) {
        onConnectionChange({ isConnected: isHealthy, error });
      }
    }
  };
  
  // Do an initial check
  checkConnection();
  
  // Set up regular polling
  const interval = setInterval(checkConnection, pollingIntervalMs);
  
  // Return function to clear the interval
  return () => clearInterval(interval);
};
