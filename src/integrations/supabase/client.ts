
// This file is automatically generated. Do not edit it directly.
import { createClient } from '@supabase/supabase-js';
import { toast } from 'sonner';
import type { Database } from './types';

// Use environment variables from .env
const SUPABASE_URL = import.meta.env.VITE_SUPABASE_URL || "https://vqdlsidkucrownbfuouq.supabase.co";
const SUPABASE_PUBLISHABLE_KEY = import.meta.env.VITE_SUPABASE_ANON_KEY || "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InZxZGxzaWRrdWNyb3duYmZ1b3VxIiwicm9sZSI6ImFub24iLCJpYXQiOjE3MzQzMDc4NDgsImV4cCI6MjA0OTg4Mzg0OH0.ARDnjN_J_bz74zQfV7IRDrq6ZL5-xs9L21zI3eG6O5Y";

// Create client with improved retry configuration and connection recovery mechanisms
export const supabase = createClient<Database>(
  SUPABASE_URL, 
  SUPABASE_PUBLISHABLE_KEY,
  {
    auth: {
      persistSession: true,
      autoRefreshToken: true,
    },
    global: {
      fetch: (...args) => {
        // Enhanced fetch with automatic retry logic for network issues
        const fetchWithRetry = async (retries = 3, backoffDelay = 300) => {
          try {
            return await fetch(...args);
          } catch (err) {
            if (retries <= 0) {
              throw err;
            }
            // Exponential backoff
            await new Promise(resolve => setTimeout(resolve, backoffDelay));
            return fetchWithRetry(retries - 1, backoffDelay * 2);
          }
        };
        return fetchWithRetry();
      },
      headers: {
        'x-application-name': 'fleet-management-system',
        'x-client-info': 'supabase-js/2.38.4',
      },
    },
    // Improve retry configuration for better resilience
    retryAttempts: 5,
    retryInterval: attempt => Math.min(1000 * Math.pow(2, attempt), 10000), // Exponential backoff with max 10s
  }
);

// Connection status cache to avoid repeated health checks
let lastHealthCheck = {
  timestamp: 0,
  isHealthy: true,
  error: null as string | null
};
const HEALTH_CACHE_TTL = 10000; // 10 seconds

// Add a function to test connection with better caching and reliability
export const testConnection = async (): Promise<boolean> => {
  try {
    // Use cached result if recent
    const now = Date.now();
    if (now - lastHealthCheck.timestamp < HEALTH_CACHE_TTL) {
      return lastHealthCheck.isHealthy;
    }
    
    // Perform lightweight health check
    const { error } = await supabase.from('vehicles').select('count', { count: 'exact', head: true });
    
    const isHealthy = !error;
    
    // Update cache
    lastHealthCheck = {
      timestamp: now,
      isHealthy,
      error: error ? error.message : null
    };
    
    return isHealthy;
  } catch (err) {
    console.error('Supabase connection test failed:', err);
    
    // Update cache with error state
    lastHealthCheck = {
      timestamp: Date.now(),
      isHealthy: false,
      error: err instanceof Error ? err.message : 'Unknown connection error'
    };
    
    return false;
  }
};

// Export an enhanced health check function with detailed diagnostics
export const checkSupabaseHealth = async (): Promise<{ 
  isHealthy: boolean; 
  error?: string; 
  latency?: number;
  timestamp: number;
}> => {
  try {
    // Use cached result if recent
    const now = Date.now();
    if (now - lastHealthCheck.timestamp < HEALTH_CACHE_TTL) {
      return { 
        isHealthy: lastHealthCheck.isHealthy,
        error: lastHealthCheck.error || undefined,
        timestamp: lastHealthCheck.timestamp
      };
    }
    
    const startTime = performance.now();
    
    // Perform lightweight health check
    const { error } = await supabase.from('vehicles').select('count', { count: 'exact', head: true });
    
    const endTime = performance.now();
    const latency = Math.round(endTime - startTime);
    
    if (error) {
      console.error('Supabase health check failed:', error);
      
      // Update cache
      lastHealthCheck = {
        timestamp: now,
        isHealthy: false,
        error: error.message
      };
      
      return { 
        isHealthy: false, 
        error: error.message,
        latency,
        timestamp: now
      };
    }
    
    // Update cache with healthy state
    lastHealthCheck = {
      timestamp: now,
      isHealthy: true,
      error: null
    };
    
    return { 
      isHealthy: true,
      latency,
      timestamp: now
    };
  } catch (err) {
    const errorMessage = err instanceof Error ? err.message : 'Unknown error checking Supabase connection';
    console.error('Supabase connection error:', errorMessage);
    
    // Update cache with error state
    lastHealthCheck = {
      timestamp: Date.now(),
      isHealthy: false,
      error: errorMessage
    };
    
    return { 
      isHealthy: false, 
      error: errorMessage,
      timestamp: Date.now()
    };
  }
};

// Check connection with multiple retries and exponential backoff
export const checkConnectionWithRetry = async (
  retries = 3, 
  initialDelay = 1000
): Promise<boolean> => {
  let attempts = 0;
  let delay = initialDelay;
  
  while (attempts < retries) {
    const { isHealthy } = await checkSupabaseHealth();
    if (isHealthy) return true;
    
    attempts++;
    if (attempts < retries) {
      console.log(`Connection attempt ${attempts} failed, retrying in ${delay}ms...`);
      await new Promise(resolve => setTimeout(resolve, delay));
      delay = Math.min(delay * 2, 10000); // Exponential backoff with max 10s
    }
  }
  
  console.error(`Failed to connect to database after ${retries} attempts`);
  return false;
};

// A unified function to monitor database connectivity with UI feedback
export const monitorDatabaseConnection = (
  onConnectionChange?: (status: { isConnected: boolean, error?: string }) => void,
  pollingIntervalMs = 30000
): () => void => {
  let previousStatus = true;
  
  const checkConnection = async () => {
    const { isHealthy, error, latency } = await checkSupabaseHealth();
    
    // Only notify if the status has changed
    if (isHealthy !== previousStatus) {
      previousStatus = isHealthy;
      
      if (!isHealthy) {
        console.error(`Database connection lost: ${error}`);
        toast.error('Database connection lost', {
          description: `Cannot connect to database: ${error || 'Check your internet connection'}`,
          duration: 0, // Keep until dismissed or reconnected
          id: 'db-connection-error'
        });
      } else {
        console.log(`Database connection restored (latency: ${latency}ms)`);
        toast.success('Database connection restored', {
          description: 'Your connection to the database has been re-established',
          id: 'db-connection-error'
        });
      }
      
      if (onConnectionChange) {
        onConnectionChange({ isConnected: isHealthy, error });
      }
    }
  };
  
  // Do an initial check
  checkConnection();
  
  // Set up regular polling
  const interval = setInterval(checkConnection, pollingIntervalMs);
  
  // Return function to clear the interval
  return () => clearInterval(interval);
};
