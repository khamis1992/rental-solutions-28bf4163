[plugin:vite:react-swc] × the name `prepareArabicText` is defined multiple times
     ╭─[/home/runner/workspace/src/utils/csv-utils.ts:1:1]
   1 │ import { prepareArabicText, containsArabic } from './arabic-text-utils';
     ·          ────────┬────────
     ·                  ╰── previous definition of `prepareArabicText` here
   2 │ 
   3 │ /**
   4 │  * Utility functions for CSV file operations
   5 │  */
   6 │ 
   7 │ /**
   8 │  * Generate and download a CSV template file
   9 │  * @param fields Array of field names to use as headers
  10 │  * @param filename Name of the file to download
  11 │  */
  12 │ export function downloadCSVTemplate(fields: string[], filename: string): void {
  13 │   // Generate CSV headers
  14 │   const headers = fields.join(',');
  15 │ 
  16 │   // Create a CSV file with headers only
  17 │   const csvContent = `${headers}\n`;
  18 │ 
  19 │   // Add UTF-8 BOM for Excel compatibility
  20 │   const BOM = '\uFEFF';
  21 │   const blob = new Blob([BOM + csvContent], { type: 'text/csv;charset=utf-8;' });
  22 │ 
  23 │   // Create a URL for the blob
  24 │   const url = URL.createObjectURL(blob);
  25 │ 
  26 │   // Create a temporary link to trigger the download
  27 │   const link = document.createElement('a');
  28 │   link.href = url;
  29 │   link.setAttribute('download', filename);
  30 │ 
  31 │   // Add to document, click and remove to trigger download
  32 │   document.body.appendChild(link);
  33 │   link.click();
  34 │   document.body.removeChild(link);
  35 │ 
  36 │   // Clean up the URL object
  37 │   URL.revokeObjectURL(url);
  38 │ }
  39 │ 
  40 │ /**
  41 │  * Parse a CSV file to an array of objects
  42 │  * Type-safe version to avoid deep type instantiation errors
  43 │  * 
  44 │  * @param file The File object to parse
  45 │  * @param headerMap Map of CSV headers to object properties
  46 │  * @returns Promise resolving to array of parsed objects
  47 │  */
  48 │ export function parseCSVFile<T extends Record<string, any>>(
  49 │   file: File, 
  50 │   headerMap: Record<string, keyof T & string>
  51 │ ): Promise<T[]> {
  52 │   return new Promise((resolve, reject) => {
  53 │     const reader = new FileReader();
  54 │ 
  55 │     reader.onload = (event) => {
  56 │       try {
  57 │         const csvText = event.target?.result as string;
  58 │         const lines = csvText.split('\n').filter(line => line.trim() !== '');
  59 │ 
  60 │         // Extract and validate headers
  61 │         const headers = lines[0].split(',').map(header => header.trim());
  62 │ 
  63 │         // Process data rows
  64 │         const results: T[] = [];
  65 │ 
  66 │         for (let i = 1; i < lines.length; i++) {
  67 │           const line = lines[i].trim();
  68 │           if (!line) continue;
  69 │ 
  70 │           // Handle quoted values properly
  71 │           const values: string[] = [];
  72 │           let current = '';
  73 │           let inQuotes = false;
  74 │ 
  75 │           for (let j = 0; j < line.length; j++) {
  76 │             const char = line[j];
  77 │ 
  78 │             if (char === '"' && (j === 0 || line[j-1] !== '\\')) {
  79 │               inQuotes = !inQuotes;
  80 │             } else if (char === ',' && !inQuotes) {
  81 │               values.push(current);
  82 │               current = '';
  83 │             } else {
  84 │               current += char;
  85 │             }
  86 │           }
  87 │ 
  88 │           // Push the last value
  89 │           values.push(current);
  90 │ 
  91 │           // Create object using headerMap
  92 │           const obj = {} as any;
  93 │ 
  94 │           headers.forEach((header, index) => {
  95 │             const mappedKey = headerMap[header];
  96 │             if (mappedKey && values[index] !== undefined) {
  97 │               obj[mappedKey] = values[index].replace(/^"|"$/g, ''); // Remove surrounding quotes
  98 │             }
  99 │           });
 100 │ 
 101 │           results.push(obj as T);
 102 │         }
 103 │ 
 104 │         resolve(results);
 105 │       } catch (error) {
 106 │         reject(error);
 107 │       }
 108 │     };
 109 │ 
 110 │     reader.onerror = (error) => {
 111 │       reject(error);
 112 │     };
 113 │ 
 114 │     reader.readAsText(file);
 115 │   });
 116 │ }
 117 │ 
 118 │ /**
 119 │  * Preview the first few rows of a CSV file
 120 │  * @param file The File object to preview
 121 │  * @param maxRows Maximum number of rows to return (default: 5)
 122 │  * @returns Promise resolving to array with headers and rows
 123 │  */
 124 │ export function previewCSVFile(file: File, maxRows: number = 5): Promise<{headers: string[], rows: string[][]}> {
 125 │   return new Promise((resolve, reject) => {
 126 │     const reader = new FileReader();
 127 │ 
 128 │     reader.onload = (event) => {
 129 │       try {
 130 │         const csvText = event.target?.result as string;
 131 │         const lines = csvText.split('\n').filter(line => line.trim() !== '');
 132 │ 
 133 │         if (lines.length === 0) {
 134 │           throw new Error('CSV file is empty');
 135 │         }
 136 │ 
 137 │         // Extract headers
 138 │         const headers = lines[0].split(',').map(header => header.trim());
 139 │ 
 140 │         // Process only the first few rows
 141 │         const previewRows: string[][] = [];
 142 │         const rowsToProcess = Math.min(maxRows, lines.length - 1);
 143 │ 
 144 │         for (let i = 1; i <= rowsToProcess; i++) {
 145 │           const line = lines[i].trim();
 146 │           if (!line) continue;
 147 │ 
 148 │           // Handle quoted values properly
 149 │           const values: string[] = [];
 150 │           let current = '';
 151 │           let inQuotes = false;
 152 │ 
 153 │           for (let j = 0; j < line.length; j++) {
 154 │             const char = line[j];
 155 │ 
 156 │             if (char === '"' && (j === 0 || line[j-1] !== '\\')) {
 157 │               inQuotes = !inQuotes;
 158 │             } else if (char === ',' && !inQuotes) {
 159 │               values.push(current);
 160 │               current = '';
 161 │             } else {
 162 │               current += char;
 163 │             }
 164 │           }
 165 │ 
 166 │           // Push the last value
 167 │           values.push(current);
 168 │ 
 169 │           // Remove surrounding quotes from values
 170 │           const cleanedValues = values.map(val => val.replace(/^"|"$/g, ''));
 171 │           previewRows.push(cleanedValues);
 172 │         }
 173 │ 
 174 │         resolve({
 175 │           headers,
 176 │           rows: previewRows
 177 │         });
 178 │       } catch (error) {
 179 │         reject(error);
 180 │       }
 181 │     };
 182 │ 
 183 │     reader.onerror = (error) => {
 184 │       reject(error);
 185 │     };
 186 │ 
 187 │     reader.readAsText(file);
 188 │   });
 189 │ }
 190 │ 
 191 │ /**
 192 │  * Format a value for CSV export
 193 │  * @param value The value to format
 194 │  * @returns Properly formatted CSV value
 195 │  */
 196 │ export function formatCSVValue(value: any): string {
 197 │   if (value === null || value === undefined) return '';
 198 │ 
 199 │   const stringValue = String(value);
 200 │ 
 201 │   // If the value contains quotes, commas, or newlines, wrap it in quotes and escape existing quotes
 202 │   if (stringValue.includes('"') || stringValue.includes(',') || stringValue.includes('\n')) {
 203 │     return `"${stringValue.replace(/"/g, '""')}"`;
 204 │   }
 205 │ 
 206 │   return stringValue;
 207 │ }
 208 │ 
 209 │ 
 210 │ import { prepareArabicText, containsArabic } from './arabic-text-utils';
     ·          ────────┬────────
     ·                  ╰── `prepareArabicText` redefined here
 211 │ 
 212 │ export function encodeCSVText(text: string): string {
 213 │   if (!text) return '';
     ╰────
  × the name `containsArabic` is defined multiple times
     ╭─[/home/runner/workspace/src/utils/csv-utils.ts:1:1]
   1 │ import { prepareArabicText, containsArabic } from './arabic-text-utils';
     ·                             ───────┬──────
     ·                                    ╰── previous definition of `containsArabic` here
   2 │ 
   3 │ /**
   4 │  * Utility functions for CSV file operations
   5 │  */
   6 │ 
   7 │ /**
   8 │  * Generate and download a CSV template file
   9 │  * @param fields Array of field names to use as headers
  10 │  * @param filename Name of the file to download
  11 │  */
  12 │ export function downloadCSVTemplate(fields: string[], filename: string): void {
  13 │   // Generate CSV headers
  14 │   const headers = fields.join(',');
  15 │ 
  16 │   // Create a CSV file with headers only
  17 │   const csvContent = `${headers}\n`;
  18 │ 
  19 │   // Add UTF-8 BOM for Excel compatibility
  20 │   const BOM = '\uFEFF';
  21 │   const blob = new Blob([BOM + csvContent], { type: 'text/csv;charset=utf-8;' });
  22 │ 
  23 │   // Create a URL for the blob
  24 │   const url = URL.createObjectURL(blob);
  25 │ 
  26 │   // Create a temporary link to trigger the download
  27 │   const link = document.createElement('a');
  28 │   link.href = url;
  29 │   link.setAttribute('download', filename);
  30 │ 
  31 │   // Add to document, click and remove to trigger download
  32 │   document.body.appendChild(link);
  33 │   link.click();
  34 │   document.body.removeChild(link);
  35 │ 
  36 │   // Clean up the URL object
  37 │   URL.revokeObjectURL(url);
  38 │ }
  39 │ 
  40 │ /**
  41 │  * Parse a CSV file to an array of objects
  42 │  * Type-safe version to avoid deep type instantiation errors
  43 │  * 
  44 │  * @param file The File object to parse
  45 │  * @param headerMap Map of CSV headers to object properties
  46 │  * @returns Promise resolving to array of parsed objects
  47 │  */
  48 │ export function parseCSVFile<T extends Record<string, any>>(
  49 │   file: File, 
  50 │   headerMap: Record<string, keyof T & string>
  51 │ ): Promise<T[]> {
  52 │   return new Promise((resolve, reject) => {
  53 │     const reader = new FileReader();
  54 │ 
  55 │     reader.onload = (event) => {
  56 │       try {
  57 │         const csvText = event.target?.result as string;
  58 │         const lines = csvText.split('\n').filter(line => line.trim() !== '');
  59 │ 
  60 │         // Extract and validate headers
  61 │         const headers = lines[0].split(',').map(header => header.trim());
  62 │ 
  63 │         // Process data rows
  64 │         const results: T[] = [];
  65 │ 
  66 │         for (let i = 1; i < lines.length; i++) {
  67 │           const line = lines[i].trim();
  68 │           if (!line) continue;
  69 │ 
  70 │           // Handle quoted values properly
  71 │           const values: string[] = [];
  72 │           let current = '';
  73 │           let inQuotes = false;
  74 │ 
  75 │           for (let j = 0; j < line.length; j++) {
  76 │             const char = line[j];
  77 │ 
  78 │             if (char === '"' && (j === 0 || line[j-1] !== '\\')) {
  79 │               inQuotes = !inQuotes;
  80 │             } else if (char === ',' && !inQuotes) {
  81 │               values.push(current);
  82 │               current = '';
  83 │             } else {
  84 │               current += char;
  85 │             }
  86 │           }
  87 │ 
  88 │           // Push the last value
  89 │           values.push(current);
  90 │ 
  91 │           // Create object using headerMap
  92 │           const obj = {} as any;
  93 │ 
  94 │           headers.forEach((header, index) => {
  95 │             const mappedKey = headerMap[header];
  96 │             if (mappedKey && values[index] !== undefined) {
  97 │               obj[mappedKey] = values[index].replace(/^"|"$/g, ''); // Remove surrounding quotes
  98 │             }
  99 │           });
 100 │ 
 101 │           results.push(obj as T);
 102 │         }
 103 │ 
 104 │         resolve(results);
 105 │       } catch (error) {
 106 │         reject(error);
 107 │       }
 108 │     };
 109 │ 
 110 │     reader.onerror = (error) => {
 111 │       reject(error);
 112 │     };
 113 │ 
 114 │     reader.readAsText(file);
 115 │   });
 116 │ }
 117 │ 
 118 │ /**
 119 │  * Preview the first few rows of a CSV file
 120 │  * @param file The File object to preview
 121 │  * @param maxRows Maximum number of rows to return (default: 5)
 122 │  * @returns Promise resolving to array with headers and rows
 123 │  */
 124 │ export function previewCSVFile(file: File, maxRows: number = 5): Promise<{headers: string[], rows: string[][]}> {
 125 │   return new Promise((resolve, reject) => {
 126 │     const reader = new FileReader();
 127 │ 
 128 │     reader.onload = (event) => {
 129 │       try {
 130 │         const csvText = event.target?.result as string;
 131 │         const lines = csvText.split('\n').filter(line => line.trim() !== '');
 132 │ 
 133 │         if (lines.length === 0) {
 134 │           throw new Error('CSV file is empty');
 135 │         }
 136 │ 
 137 │         // Extract headers
 138 │         const headers = lines[0].split(',').map(header => header.trim());
 139 │ 
 140 │         // Process only the first few rows
 141 │         const previewRows: string[][] = [];
 142 │         const rowsToProcess = Math.min(maxRows, lines.length - 1);
 143 │ 
 144 │         for (let i = 1; i <= rowsToProcess; i++) {
 145 │           const line = lines[i].trim();
 146 │           if (!line) continue;
 147 │ 
 148 │           // Handle quoted values properly
 149 │           const values: string[] = [];
 150 │           let current = '';
 151 │           let inQuotes = false;
 152 │ 
 153 │           for (let j = 0; j < line.length; j++) {
 154 │             const char = line[j];
 155 │ 
 156 │             if (char === '"' && (j === 0 || line[j-1] !== '\\')) {
 157 │               inQuotes = !inQuotes;
 158 │             } else if (char === ',' && !inQuotes) {
 159 │               values.push(current);
 160 │               current = '';
 161 │             } else {
 162 │               current += char;
 163 │             }
 164 │           }
 165 │ 
 166 │           // Push the last value
 167 │           values.push(current);
 168 │ 
 169 │           // Remove surrounding quotes from values
 170 │           const cleanedValues = values.map(val => val.replace(/^"|"$/g, ''));
 171 │           previewRows.push(cleanedValues);
 172 │         }
 173 │ 
 174 │         resolve({
 175 │           headers,
 176 │           rows: previewRows
 177 │         });
 178 │       } catch (error) {
 179 │         reject(error);
 180 │       }
 181 │     };
 182 │ 
 183 │     reader.onerror = (error) => {
 184 │       reject(error);
 185 │     };
 186 │ 
 187 │     reader.readAsText(file);
 188 │   });
 189 │ }
 190 │ 
 191 │ /**
 192 │  * Format a value for CSV export
 193 │  * @param value The value to format
 194 │  * @returns Properly formatted CSV value
 195 │  */
 196 │ export function formatCSVValue(value: any): string {
 197 │   if (value === null || value === undefined) return '';
 198 │ 
 199 │   const stringValue = String(value);
 200 │ 
 201 │   // If the value contains quotes, commas, or newlines, wrap it in quotes and escape existing quotes
 202 │   if (stringValue.includes('"') || stringValue.includes(',') || stringValue.includes('\n')) {
 203 │     return `"${stringValue.replace(/"/g, '""')}"`;
 204 │   }
 205 │ 
 206 │   return stringValue;
 207 │ }
 208 │ 
 209 │ 
 210 │ import { prepareArabicText, containsArabic } from './arabic-text-utils';
     ·                             ───────┬──────
     ·                                    ╰── `containsArabic` redefined here
 211 │ 
 212 │ export function encodeCSVText(text: string): string {
 213 │   if (!text) return '';
     ╰────
/home/runner/workspace/src/utils/csv-utils.ts:1:1
1  |  import { prepareArabicText, containsArabic } from './arabic-text-utils';
   |   ^
2  |  
3  |  /**