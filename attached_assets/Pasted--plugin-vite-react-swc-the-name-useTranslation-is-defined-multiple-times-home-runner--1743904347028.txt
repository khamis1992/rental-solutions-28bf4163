[plugin:vite:react-swc] × the name `useTranslation` is defined multiple times
     ╭─[/home/runner/workspace/src/utils/rtl-utils.ts:1:1]
   1 │ import { useTranslation } from '@/contexts/TranslationContext';
     ·          ───────┬──────
     ·                 ╰── previous definition of `useTranslation` here
   2 │ import { cn } from '@/lib/utils';
   3 │ 
   4 │ /**
   5 │  * Hook to provide directional-aware CSS classes
   6 │  * @param baseClasses - classes to apply in both directions
   7 │  * @param ltrClasses - classes to apply only in LTR mode
   8 │  * @param rtlClasses - classes to apply only in RTL mode
   9 │  * @returns combined classes based on current direction
  10 │  */
  11 │ export const useDirectionalClasses = (
  12 │   baseClasses: string,
  13 │   ltrClasses: string = '',
  14 │   rtlClasses: string = ''
  15 │ ): string => {
  16 │   const { isRTL } = useTranslation();
  17 │   
  18 │   return cn(
  19 │     baseClasses,
  20 │     isRTL ? rtlClasses : ltrClasses
  21 │   );
  22 │ };
  23 │ 
  24 │ /**
  25 │  * Helper function to flip margins, paddings, etc. for RTL support
  26 │  * @param prefixClass - Base class prefix (e.g., 'ml', 'mr', 'pl', 'pr')
  27 │  * @param size - Size value (e.g., '2', '4', etc.)
  28 │  * @returns Appropriate directional class based on current direction
  29 │  */
  30 │ export const getDirectionalMargin = (
  31 │   prefixClass: 'ml' | 'mr' | 'pl' | 'pr',
  32 │   size: string
  33 │ ): string => {
  34 │   const { isRTL } = useTranslation();
  35 │   
  36 │   // Flip margins and paddings for RTL
  37 │   const mapping = {
  38 │     ml: isRTL ? 'mr' : 'ml',
  39 │     mr: isRTL ? 'ml' : 'mr',
  40 │     pl: isRTL ? 'pr' : 'pl',
  41 │     pr: isRTL ? 'pl' : 'pr'
  42 │   };
  43 │   
  44 │   return `${mapping[prefixClass]}-${size}`;
  45 │ };
  46 │ 
  47 │ /**
  48 │  * Converts directional classes like ml/mr/pl/pr to their RTL-aware versions
  49 │  * @param classes - Space-separated string of classes
  50 │  * @returns Properly flipped classes for RTL
  51 │  */
  52 │ const classCache = new Map<string, string>();
  53 │ 
  54 │ export const getDirectionalClasses = (classes: string): string => {
  55 │   const { isRTL } = useTranslation();
  56 │   
  57 │   if (!isRTL) return classes;
  58 │   
  59 │   const cacheKey = `${classes}-${isRTL}`;
  60 │   if (classCache.has(cacheKey)) {
  61 │     return classCache.get(cacheKey)!;
  62 │   } // No changes needed for LTR
  63 │   
  64 │   return classes.split(' ').map(cls => {
  65 │     // Match padding and margin patterns
  66 │     const marginMatch = cls.match(/^(m[lr]|margin-[lr])\-(.+)$/);
  67 │     const paddingMatch = cls.match(/^(p[lr]|padding-[lr])\-(.+)$/);
  68 │     
  69 │     if (marginMatch) {
  70 │       const [, prefix, size] = marginMatch;
  71 │       if (prefix === 'ml' || prefix === 'margin-l') return `mr-${size}`;
  72 │       if (prefix === 'mr' || prefix === 'margin-r') return `ml-${size}`;
  73 │     }
  74 │     
  75 │     if (paddingMatch) {
  76 │       const [, prefix, size] = paddingMatch;
  77 │       if (prefix === 'pl' || prefix === 'padding-l') return `pr-${size}`;
  78 │       if (prefix === 'pr' || prefix === 'padding-r') return `pl-${size}`;
  79 │     }
  80 │     
  81 │     // Left/right text alignment
  82 │     if (cls === 'text-left') return 'text-right';
  83 │     if (cls === 'text-right') return 'text-left';
  84 │     
  85 │     // Left/right flex alignments
  86 │     if (cls === 'items-start') return 'items-end';
  87 │     if (cls === 'items-end') return 'items-start';
  88 │     if (cls === 'justify-start') return 'justify-end';
  89 │     if (cls === 'justify-end') return 'justify-start';
  90 │     
  91 │     // Left/right borders
  92 │     if (cls.startsWith('border-l')) return cls.replace('border-l', 'border-r');
  93 │     if (cls.startsWith('border-r')) return cls.replace('border-r', 'border-l');
  94 │     
  95 │     // Left/right positioning
  96 │     if (cls.startsWith('left-')) return cls.replace('left-', 'right-');
  97 │     if (cls.startsWith('right-')) return cls.replace('right-', 'left-');
  98 │     
  99 │     // Rounded corners
 100 │     if (cls.includes('rounded-l-')) return cls.replace('rounded-l-', 'rounded-r-');
 101 │     if (cls.includes('rounded-r-')) return cls.replace('rounded-r-', 'rounded-l-');
 102 │     if (cls.includes('rounded-tl-')) return cls.replace('rounded-tl-', 'rounded-tr-');
 103 │     if (cls.includes('rounded-tr-')) return cls.replace('rounded-tr-', 'rounded-tl-');
 104 │     if (cls.includes('rounded-bl-')) return cls.replace('rounded-bl-', 'rounded-br-');
 105 │     if (cls.includes('rounded-br-')) return cls.replace('rounded-br-', 'rounded-bl-');
 106 │     
 107 │     // Space between elements in flexbox
 108 │     if (cls === 'space-x-reverse') return '';
 109 │     if (cls.startsWith('space-x-')) return `${cls} space-x-reverse`;
 110 │     
 111 │     // Keep other classes unchanged
 112 │     return cls;
 113 │   }).join(' ');
 114 │ };
 115 │ 
 116 │ /**
 117 │  * Returns appropriate directional flex class based on current language
 118 │  * @returns The flex direction class for the current language
 119 │  */
 120 │ export const getDirectionalFlexClass = (): string => {
 121 │   const { isRTL } = useTranslation();
 122 │   return isRTL ? 'flex-row-reverse' : 'flex-row';
 123 │ };
 124 │ 
 125 │ /**
 126 │  * Returns the appropriate text-align class based on current language
 127 │  * @returns The text alignment class for the current language
 128 │  */
 129 │ export const getDirectionalTextAlign = (): string => {
 130 │   const { isRTL } = useTranslation();
 131 │   return isRTL ? 'text-right' : 'text-left';
 132 │ };
 133 │ 
 134 │ /**
 135 │  * Helper function to get appropriate icon for directional navigation
 136 │  * @param iconType Type of directional icon (e.g., 'arrow', 'chevron')
 137 │  * @returns The icon component to use based on direction
 138 │  */
 139 │ export const getDirectionalIcon = (iconType: 'arrow' | 'chevron') => {
 140 │   const { isRTL } = useTranslation();
 141 │   
 142 │   // You will need to import these from lucide-react where this function is used
 143 │   if (iconType === 'arrow') {
 144 │     return isRTL ? 'ArrowRight' : 'ArrowLeft';
 145 │   } else {
 146 │     return isRTL ? 'ChevronRight' : 'ChevronLeft';
 147 │   }
 148 │ };
 149 │ 
 150 │ import { useTranslation } from 'react-i18next';
     ·          ───────┬──────
     ·                 ╰── `useTranslation` redefined here
 151 │ 
 152 │ export const useIsRTL = () => {
 153 │   const { i18n } = useTranslation();
     ╰────